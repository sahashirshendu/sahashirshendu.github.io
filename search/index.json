[{"content":"Prerequisites: Fortran Compiler (preferably in any linux distribution) and a text editor, of course :)\nfibonacci.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 program fibo implicit none integer(8) i real(8) f0, f1, temp print *, \u0026#34;The first 50 Fibonacci numbers :\u0026#34; f0 = 0 f1 = 1 do i = 1, 50 print *, f0 temp = f0 + f1 f0 = f1 f1 = temp end do end bisection.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 program bisection print *, \u0026#34;Enter tolerance :\u0026#34; read *, tol print *, \u0026#34;Enter guess value :\u0026#34; read *, x0, x1 if ((f(x0) * f(x1)) .ge. 0.0) then print *, \u0026#34;Initial values do not bracket the root!\u0026#34; stop end if print *, \u0026#39; i\u0026#39;,\u0026#39; x0\u0026#39;,\u0026#39; x2\u0026#39;,\u0026#39; f(x2)\u0026#39; do 11 i = 1, 1000000 x2 = (x0 + x1)/2 print 16, i, x0, x2, f(x2) if ((f(x2) * f(x1)) .le. 0.0) then x0 = x2 else x1 = x2 end if err = abs((x1 - x0)/x1) if (err .le. tol) go to 12 11 continue 12 print *, \u0026#39;The root is =\u0026#39;, x2 stop end function f(x) f = x**3 - 7.0 return end newton_raphson.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 program nr print *, \u0026#34;Enter tolerance :\u0026#34; read *, tol print *, \u0026#34;Enter guess value :\u0026#34; read *, x0 if (abs(df(x0)) .le. 1e-5) then print *, \u0026#34;Slope is too small to proceed!\u0026#34; stop end if print *, \u0026#39; i\u0026#39;,\u0026#39; x0\u0026#39;,\u0026#39; x1\u0026#39;,\u0026#39; f(x1)\u0026#39; do 11 i = 1, 100000 x1 = x0 - f(x0) / df(x0) err = abs((x1 - x0) / x1) print *, i, x0, x1, f(x1) if (err .le. 0.00001) go to 12 x0 = x1 11 continue 12 print *, \u0026#34;The root is x =\u0026#34;, x1 stop end function f(x) f = x ** 3 - 7.0 return end function df(x) df = 3 * x ** 2 return end regula_falsi.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 program rf print *, \u0026#34;Enter tolerance :\u0026#34; read *, tol print *, \u0026#34;Enter guess values :\u0026#34; read *, x0, x1 print *, \u0026#39; i\u0026#39;,\u0026#39; x0\u0026#39;,\u0026#39; x2\u0026#39;,\u0026#39; f(x2)\u0026#39; do 11 i = 1, 100000 x2 = (x0 * f(x1) - x1 * f(x0)) / (f(x1) - f(x0)) sgp = f(x2) * f(x0) print *, i, x0, x2, f(x2) if (sgp .le. 0.0) then x1 = x2 else x0 = x2 endif if (abs(f(x2)) .le. tol) go to 12 11 continue 12 print *, \u0026#34;The root is x =\u0026#34;, x2 stop end function f(x) f = x ** 3 - 7 return end secant.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 program secant print *, \u0026#34;Enter tolerance :\u0026#34; read *, tol print *, \u0026#34;Enter guess values :\u0026#34; read *, x0, x1 print *, \u0026#39; i\u0026#39;,\u0026#39; x2\u0026#39;,\u0026#39; f(x2)\u0026#39; do 17 i = 1, 10000 x2 = (x0 * f(x1) - x1 * f(x0)) / (f(x1) - f(x0)) print *, i, x0, x2, f(x2) if (abs(f(x2)) .le. tol) go to 18 x0 = x1 x1 = x2 17 continue 18 print *, \u0026#34;The root is x =\u0026#34;, x2 stop end function f(x) f = x ** 3 - 7 return end legendre.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ! Plots of P3(x), P4(x) program legendrepol implicit none real legendre, x, xmin, xmax, dx xmin = -1.0 xmax = 1.0 dx = 0.00001 x = xmin open (2, file=\u0026#34;legendre.dat\u0026#34;) do while (x .lt. xmax) write (2, *) x, legendre(x, 3), legendre(x, 4) x = x + dx end do close(2) end function legendre(x, n) implicit none integer n, i real legendre, P(0:n), x P(0) = 1 P(1) = x if (n .le. 1) then legendre = P(n) else do i = 1, n - 1 P(i+1) = ((2*i+1) * x * P(i) - float(i) * P(i-1)) / float(i+1) end do legendre = P(n) end if return end legendre_ort.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 program legendrepol implicit none integer m, n real legendre, x, xmin, xmax, dx, ints, intd, sums, sumd xmin = -1.0 xmax = 1.0 dx = 0.00001 x = xmin m = 4 n = 5 sums = 0 sumd = 0 do while (x .lt. xmax) sums = sums + legendre(x, n) * legendre(x, n) sumd = sumd + legendre(x, m) * legendre(x, n) x = x + dx end do print *, \u0026#34;Integral of P5(x)*P5(x) =\u0026#34;, sums * dx print *, \u0026#34;Integral of P4(x)*P5(x) =\u0026#34;, sumd * dx end function legendre(x, n) implicit none integer n, i real legendre, P(0:n), x P(0) = 1 P(1) = x if (n .le. 1) then legendre = P(n) else do i = 1, n - 1 P(i+1) = ((2*i+1) * x * P(i) - float(i) * P(i-1)) / float(i+1) end do legendre = P(n) end if return end horner.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 program hornerpoly real, allocatable :: a(:) print *, \u0026#34;Enter n :\u0026#34; read *, n print *, \u0026#34;Enter x :\u0026#34; read *, x allocate(a(0:n)) print *, \u0026#34;Enter the coefficients :\u0026#34; read *, a horner = a(n) do i = n, 1, -1 horner = horner * x + a(i - 1) end do print *,\u0026#34;Value of the polynomial at x =\u0026#34;, horner end deflation.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 program deflatepoly real, allocatable :: a(:), b(:) print *, \u0026#34;Enter the order of the polynomial :\u0026#34; read *, n allocate(a(0:n), b(0:n-1)) print *, \u0026#34;Enter the coefficients :\u0026#34; print *, \u0026#34;(in increasing value of order)\u0026#34; read *, a print *, \u0026#34;Enter a root :\u0026#34; read *, r b(n - 1) = a(n) do i = 1, n - 1 b(n - (i + 1)) = a(n - i) + r * b(n - i) end do print *, \u0026#34;Coefficients of the polynomial =\u0026#34;, a print *, \u0026#34;Coefficients of the deflated polynomial =\u0026#34;, b end simul.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 print *, \u0026#34;Enter a, b, c :\u0026#34; read *, a, b, c print *, \u0026#34;Enter p, q, r:\u0026#34; read *, p, q, r q = q - p * b / a r = r - p * c / a if (q .eq. 0) then print *, \u0026#34;No solution!\u0026#34; else y = r / q x = (c - b * y) / a print *, \u0026#34;x =\u0026#34;, x print *, \u0026#34;y =\u0026#34;, y end if end gelm.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 program gelm integer n, i, j, k, q, rn real k1,k2 real,allocatable::a(:,:),x(:) print*,\u0026#39;Enter n :\u0026#39; read*,n allocate(a(n,n+1)) allocate(x(n)) print*,\u0026#39;Enter the matrix :\u0026#39; do i=1,n read*,(a(i,j),j=1,n+1) end do print*,\u0026#39;Matrix =\u0026#39; do i=1,n print*,(a(i,j),j=1,n+1) end do do k=1,n-1 ! Pivoting big=abs(a(k,k)) rn=k do m=k+1,n if (abs(a(m,k)).gt.big) then big=abs(a(m,k)) rn=m end if end do if (rn.ne.k) then do q=k,n+1 temp=a(k,q) a(k,q)=a(rn,q) a(rn,q)=temp end do end if ! End of pivoting k1=a(k,k) do i=k+1,n k2=a(i,k)/k1 do j=k,n+1 a(i,j)=a(i,j)-k2*a(k,j) end do end do end do print*,\u0026#39;Upper triangular matrix =\u0026#39; do i=1,n print*,(a(i,j),j=1,n+1) end do x(n)=a(n,n+1)/a(n,n) do i=n-1,1,-1 c=0 do j=i+1,n c=c+a(i,j)*x(j) end do x(i)=(a(i,n+1)-c)/a(i,i) end do print*,\u0026#39;Solution =\u0026#39; do i=1,n print*,x(i) end do end gseidel.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 program seidel real,allocatable::a(:,:),x(:) print*,\u0026#39;Enter n :\u0026#39; read*,n e=0.00001 maxit=10000 allocate(a(n,n+1)) allocate(x(n)) print*,\u0026#39;Enter the matrix :\u0026#39; do i=1,n read*,(a(i,j),j=1,n+1) end do print*,\u0026#39;Matrix :\u0026#39; do i=1,n print*,(a(i,j),j=1,n+1) end do do i=1,n x(i)=0 end do print*,\u0026#39;Iterations :\u0026#39; do iter=1,maxit big=0 do i=1,n sum=0 do j=1,n if (j.ne.i) then sum=sum+a(i,j)*x(j) end if end do temp=(a(i,n+1)-sum)/a(i,i) relerror=abs((x(i)-temp)/temp) if (relerror.gt.big) then big=relerror end if x(i)=temp end do print*, x if(big.le.e) then print*,\u0026#39;Converges to a solution\u0026#39; print*,\u0026#39;Solution =\u0026#39; do i=1,n print*,x(i) end do stop end if end do print*,\u0026#39;Does not converge in maxit iterations\u0026#39; print*,\u0026#39;Solution =\u0026#39; do i=1,n print*,x(i) end do end ","date":"2022-07-04T00:00:00Z","permalink":"https://sahashirshendu.github.io/p/phys04c8-laboratory/","title":"PHYS04C8 Laboratory"},{"content":"Using Git and basic command-line tools to back up and sync various code. You can use the setup to store something like a bunch of code files, and copy them to any machine you want and also sync the changes made.\nSetting up the Repository 0. Prerequisites We need to have git installed on our computer and a functional internet connection. Now, there is a point worth noting. The sync works seamlessly only if one has one\u0026rsquo;s git credentials stored or cached [Otherwise you must enter your git username and password for every pull or push command] .\nYou can use the following command(s) to store the credentials. After entering the command, you have to enter the credentials the first time you are prompted, and then those will be stored for future. For permanently storing the credentials,\n1 git config --global credential.helper store For saving the credntials for only one session,\n1 git config --global credential.helper cache [Another thing, GitHub now does not allow you to store the password using the previous command, rather you have to generate a personal access token from the GitHub accounts page and use that. GitLab works fine with passwords.]\n1. Creating the Repository Here we shall use GitHub or GitLab to store our files. We need to create an empty repository in GitHub or GitLab for this purpose. You can create either a public repo or a private one, but for this kind of a project a private repo should be just fine.\n2. Pushing contents in the local folder to the remote repo Now that the remote repo is set up, we have to initiate a git repo in the local folder we want to sync. Open a terminal in the folder and run -\n1 2 3 git init git add . git commit -m \u0026#34;Initial Commit\u0026#34; Next we have to connect the local repo to the remote repo. For that we run -\n1 git remote add origin https://REPOURL.git Note that the https://REPOURL.git part should look something like https://github.com/USERNAME/REPONAME.git or https://gitlab.com/USERNAME/REPONAME.git.\nAnd finally, push the contents -\n1 git push -u origin master In a few seconds, all the contents of our ocal folder would be available on the remote repo! Now we could just run the few previous commands everytime we make any change to the contents of the folder, but that would be tedious, won\u0026rsquo;t it!? So let\u0026rsquo;s atomate this by writing a smalll shell script!\nSyncing the local folder with the Git client The Shell Script Create a shell script (in the folder to be synced) named sync with the text editor of your choice and its contents as follows -\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash gstatus=$(git status --porcelain) if [ ${#gstatus} -ne 0 ]; then git pull git add --all printf \u0026#34;Enter Commit Message : \u0026#34; read msg git commit -m \u0026#34;$msg\u0026#34; # git pull --rebase git push fi Now, you should never execute a script from any random site on the web as it could make your computer a pile of e-waste. For this script, the meaning is quite simple - The gstatus variable lists the changes made in the files. If there are not any changes, it does nothing. But if there are, it pulls the changes in the remote repo (if done from another machine), adds all the files to git, prompts you for a commit message, and pushes the changes to the remote repo.\nThen we have to make the script executable. In the terminal, run\n1 chmod +x sync Moment of Truth And whenever you create a new file or change anything, just open the terminal in folder, execute the script, enter and the commit message and \u0026hellip; see the magic!\n1 ./sync Yes, we can automate this workflow with cron-job, but let\u0026rsquo;s just keep it a bit simple for now. Hope someone will find this helpful. ðŸ™‚\n","date":"2022-01-24T00:00:00Z","permalink":"https://sahashirshendu.github.io/p/how-to-back-up-code-with-a-bit-of-git/","title":"How to Back Up Code with a Bit of Git"}]