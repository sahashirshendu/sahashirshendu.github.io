[{"content":"Prerequisites: Fortran Compiler (preferably in any linux distribution) and a text editor, of course :)\nfibonacci.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 program fibo implicit none integer(8) i real(8) f0, f1, temp print *, \u0026#34;The first 50 Fibonacci numbers :\u0026#34; f0 = 0 f1 = 1 do i = 1, 50 print *, f0 temp = f0 + f1 f0 = f1 f1 = temp end do end bisection.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 program bisection print *, \u0026#34;Enter tolerance :\u0026#34; read *, tol print *, \u0026#34;Enter guess value :\u0026#34; read *, x0, x1 if ((f(x0) * f(x1)) .ge. 0.0) then print *, \u0026#34;Initial values do not bracket the root!\u0026#34; stop end if print *, \u0026#39; i\u0026#39;,\u0026#39; x0\u0026#39;,\u0026#39; x2\u0026#39;,\u0026#39; f(x2)\u0026#39; do 11 i = 1, 1000000 x2 = (x0 + x1)/2 print 16, i, x0, x2, f(x2) if ((f(x2) * f(x1)) .le. 0.0) then x0 = x2 else x1 = x2 end if err = abs((x1 - x0)/x1) if (err .le. tol) go to 12 11 continue 12 print *, \u0026#39;The root is =\u0026#39;, x2 stop end function f(x) f = x**3 - 7.0 return end newton_raphson.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 program nr print *, \u0026#34;Enter tolerance :\u0026#34; read *, tol print *, \u0026#34;Enter guess value :\u0026#34; read *, x0 if (abs(df(x0)) .le. 1e-5) then print *, \u0026#34;Slope is too small to proceed!\u0026#34; stop end if print *, \u0026#39; i\u0026#39;,\u0026#39; x0\u0026#39;,\u0026#39; x1\u0026#39;,\u0026#39; f(x1)\u0026#39; do 11 i = 1, 100000 x1 = x0 - f(x0) / df(x0) err = abs((x1 - x0) / x1) print *, i, x0, x1, f(x1) if (err .le. 0.00001) go to 12 x0 = x1 11 continue 12 print *, \u0026#34;The root is x =\u0026#34;, x1 stop end function f(x) f = x ** 3 - 7.0 return end function df(x) df = 3 * x ** 2 return end regula_falsi.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 program rf print *, \u0026#34;Enter tolerance :\u0026#34; read *, tol print *, \u0026#34;Enter guess values :\u0026#34; read *, x0, x1 print *, \u0026#39; i\u0026#39;,\u0026#39; x0\u0026#39;,\u0026#39; x2\u0026#39;,\u0026#39; f(x2)\u0026#39; do 11 i = 1, 100000 x2 = (x0 * f(x1) - x1 * f(x0)) / (f(x1) - f(x0)) sgp = f(x2) * f(x0) print *, i, x0, x2, f(x2) if (sgp .le. 0.0) then x1 = x2 else x0 = x2 endif if (abs(f(x2)) .le. tol) go to 12 11 continue 12 print *, \u0026#34;The root is x =\u0026#34;, x2 stop end function f(x) f = x ** 3 - 7 return end secant.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 program secant print *, \u0026#34;Enter tolerance :\u0026#34; read *, tol print *, \u0026#34;Enter guess values :\u0026#34; read *, x0, x1 print *, \u0026#39; i\u0026#39;,\u0026#39; x2\u0026#39;,\u0026#39; f(x2)\u0026#39; do 17 i = 1, 10000 x2 = (x0 * f(x1) - x1 * f(x0)) / (f(x1) - f(x0)) print *, i, x0, x2, f(x2) if (abs(f(x2)) .le. tol) go to 18 x0 = x1 x1 = x2 17 continue 18 print *, \u0026#34;The root is x =\u0026#34;, x2 stop end function f(x) f = x ** 3 - 7 return end legendre.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ! Plots of P3(x), P4(x) program legendrepol implicit none real legendre, x, xmin, xmax, dx xmin = -1.0 xmax = 1.0 dx = 0.00001 x = xmin open (2, file=\u0026#34;legendre.dat\u0026#34;) do while (x .lt. xmax) write (2, *) x, legendre(x, 3), legendre(x, 4) x = x + dx end do close(2) end function legendre(x, n) implicit none integer n, i real legendre, P(0:n), x P(0) = 1 P(1) = x if (n .le. 1) then legendre = P(n) else do i = 1, n - 1 P(i+1) = ((2*i+1) * x * P(i) - float(i) * P(i-1)) / float(i+1) end do legendre = P(n) end if return end legendre_ort.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 program legendrepol implicit none integer m, n real legendre, x, xmin, xmax, dx, ints, intd, sums, sumd xmin = -1.0 xmax = 1.0 dx = 0.00001 x = xmin m = 4 n = 5 sums = 0 sumd = 0 do while (x .lt. xmax) sums = sums + legendre(x, n) * legendre(x, n) sumd = sumd + legendre(x, m) * legendre(x, n) x = x + dx end do print *, \u0026#34;Integral of P5(x)*P5(x) =\u0026#34;, sums * dx print *, \u0026#34;Integral of P4(x)*P5(x) =\u0026#34;, sumd * dx end function legendre(x, n) implicit none integer n, i real legendre, P(0:n), x P(0) = 1 P(1) = x if (n .le. 1) then legendre = P(n) else do i = 1, n - 1 P(i+1) = ((2*i+1) * x * P(i) - float(i) * P(i-1)) / float(i+1) end do legendre = P(n) end if return end horner.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 program hornerpoly real, allocatable :: a(:) print *, \u0026#34;Enter n :\u0026#34; read *, n print *, \u0026#34;Enter x :\u0026#34; read *, x allocate(a(0:n)) print *, \u0026#34;Enter the coefficients :\u0026#34; read *, a horner = a(n) do i = n, 1, -1 horner = horner * x + a(i - 1) end do print *,\u0026#34;Value of the polynomial at x =\u0026#34;, horner end deflation.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 program deflatepoly real, allocatable :: a(:), b(:) print *, \u0026#34;Enter the order of the polynomial :\u0026#34; read *, n allocate(a(0:n), b(0:n-1)) print *, \u0026#34;Enter the coefficients :\u0026#34; print *, \u0026#34;(in increasing value of order)\u0026#34; read *, a print *, \u0026#34;Enter a root :\u0026#34; read *, r b(n - 1) = a(n) do i = 1, n - 1 b(n - (i + 1)) = a(n - i) + r * b(n - i) end do print *, \u0026#34;Coefficients of the polynomial =\u0026#34;, a print *, \u0026#34;Coefficients of the deflated polynomial =\u0026#34;, b end simul.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 print *, \u0026#34;Enter a, b, c :\u0026#34; read *, a, b, c print *, \u0026#34;Enter p, q, r:\u0026#34; read *, p, q, r q = q - p * b / a r = r - p * c / a if (q .eq. 0) then print *, \u0026#34;No solution!\u0026#34; else y = r / q x = (c - b * y) / a print *, \u0026#34;x =\u0026#34;, x print *, \u0026#34;y =\u0026#34;, y end if end gelm.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 program gelm integer n, i, j, k, q, rn real k1,k2 real,allocatable::a(:,:),x(:) print*,\u0026#39;Enter n :\u0026#39; read*,n allocate(a(n,n+1)) allocate(x(n)) print*,\u0026#39;Enter the matrix :\u0026#39; do i=1,n read*,(a(i,j),j=1,n+1) end do print*,\u0026#39;Matrix =\u0026#39; do i=1,n print*,(a(i,j),j=1,n+1) end do do k=1,n-1 ! Pivoting big=abs(a(k,k)) rn=k do m=k+1,n if (abs(a(m,k)).gt.big) then big=abs(a(m,k)) rn=m end if end do if (rn.ne.k) then do q=k,n+1 temp=a(k,q) a(k,q)=a(rn,q) a(rn,q)=temp end do end if ! End of pivoting k1=a(k,k) do i=k+1,n k2=a(i,k)/k1 do j=k,n+1 a(i,j)=a(i,j)-k2*a(k,j) end do end do end do print*,\u0026#39;Upper triangular matrix =\u0026#39; do i=1,n print*,(a(i,j),j=1,n+1) end do x(n)=a(n,n+1)/a(n,n) do i=n-1,1,-1 c=0 do j=i+1,n c=c+a(i,j)*x(j) end do x(i)=(a(i,n+1)-c)/a(i,i) end do print*,\u0026#39;Solution =\u0026#39; do i=1,n print*,x(i) end do end gseidel.f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 program seidel real,allocatable::a(:,:),x(:) print*,\u0026#39;Enter n :\u0026#39; read*,n e=0.00001 maxit=10000 allocate(a(n,n+1)) allocate(x(n)) print*,\u0026#39;Enter the matrix :\u0026#39; do i=1,n read*,(a(i,j),j=1,n+1) end do print*,\u0026#39;Matrix :\u0026#39; do i=1,n print*,(a(i,j),j=1,n+1) end do do i=1,n x(i)=0 end do print*,\u0026#39;Iterations :\u0026#39; do iter=1,maxit big=0 do i=1,n sum=0 do j=1,n if (j.ne.i) then sum=sum+a(i,j)*x(j) end if end do temp=(a(i,n+1)-sum)/a(i,i) relerror=abs((x(i)-temp)/temp) if (relerror.gt.big) then big=relerror end if x(i)=temp end do print*, x if(big.le.e) then print*,\u0026#39;Converges to a solution\u0026#39; print*,\u0026#39;Solution =\u0026#39; do i=1,n print*,x(i) end do stop end if end do print*,\u0026#39;Does not converge in maxit iterations\u0026#39; print*,\u0026#39;Solution =\u0026#39; do i=1,n print*,x(i) end do end ","permalink":"https://sahashirshendu.github.io/posts/mmtlabfort/","summary":"\u003cp\u003ePrerequisites: Fortran Compiler (preferably in any linux distribution) and a text editor, of course :)\u003c/p\u003e","title":"PHYS04C8 Laboratory"},{"content":"Lorem ipsum dolor sit amet, officia excepteur ex fugiat reprehenderit enim labore culpa sint ad nisi Lorem pariatur mollit ex esse exercitation amet. Nisi anim cupidatat excepteur officia. Reprehenderit nostrud nostrud ipsum Lorem est aliquip amet voluptate voluptate dolor minim nulla est proident. Nostrud officia pariatur ut officia. Sit irure elit esse ea nulla sunt ex occaecat reprehenderit commodo officia dolor Lorem duis laboris cupidatat officia voluptate. Culpa proident adipisicing id nulla nisi laboris ex in Lorem sunt duis officia eiusmod. Aliqua reprehenderit commodo ex non excepteur duis sunt velit enim. Voluptate laboris sint cupidatat ullamco ut ea consectetur et est culpa et culpa duis.\n$$\\left[-\\frac{\\hbar^2}{2m}\\nabla^2+V(\\vec{r})\\right]\\Psi(r,t)=E\\Psi(\\vec{r},t)$$\n","permalink":"https://sahashirshendu.github.io/about/","summary":"Lorem ipsum dolor sit amet, officia excepteur ex fugiat reprehenderit enim labore culpa sint ad nisi Lorem pariatur mollit ex esse exercitation amet. Nisi anim cupidatat excepteur officia. Reprehenderit nostrud nostrud ipsum Lorem est aliquip amet voluptate voluptate dolor minim nulla est proident. Nostrud officia pariatur ut officia. Sit irure elit esse ea nulla sunt ex occaecat reprehenderit commodo officia dolor Lorem duis laboris cupidatat officia voluptate. Culpa proident adipisicing id nulla nisi laboris ex in Lorem sunt duis officia eiusmod.","title":"About"},{"content":"","permalink":"https://sahashirshendu.github.io/contact/","summary":"","title":""}]